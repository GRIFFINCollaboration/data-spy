<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Data Spy Testing</title>
        <link rel="stylesheet" href="../css/qunit.css">
    </head>
    <body>
        <div id="qunit"></div>
        <div id="qunit-fixture"></div>
        <script src="../scripts/qunit.js"></script>
        <script src='../scripts/parse.js' type="text/javascript"></script>

        <script>
            //////////////////////////////////////////////////////
            // GRIFFIN parser testing
            //////////////////////////////////////////////////////

            data = [
                0x88A67C80,
                0xD0850F81,
                0x1a04FC84,
                0x73F461FF,
                0x9D74A998,
                0xA574A998,
                0xBC2461FF,

                0xC00000DE,
                0xC00000AD,
                0xC00000BE,
                0xC00000EF,

                0x057715CC,
                0x0074A998,
                0xE874A998
            ];

            QUnit.module('GRIF-16 fragment parser', {
                "setup": function(){
                    parser = new GRIF16fragmentParser;
                },

                "teardown": function(){
                    return 0;
                }
            });

            QUnit.test("typeI", function( assert ) {
                unpacked = {};
                parser.parsers['I'](data[0], unpacked);

                assert.equal(unpacked.typeIpacketType[0], 8);
                assert.equal(unpacked.moduleType[1], 'GRIF-C Master');
                assert.equal(unpacked.wordCount, 10);
                assert.equal(unpacked.masterChan, 6);
                assert.equal(unpacked.slaveChan, 7);
                assert.equal(unpacked.collectorChan, 200);
                assert.equal(unpacked.detType[1], 'HPGe Low Gain')
            });

            QUnit.test("typeII", function( assert ){
                unpacked = {};
                parser.parsers['II'](data[1], unpacked);

                assert.equal(unpacked.typeIIpacketType[0], 0xd);
                assert.equal(unpacked.networkPacketCounterValue[0], 0x850F81);

            }); 

            QUnit.test("typeIII", function( assert ){
                unpacked = {};
                parser.parsers['III'](data[2], unpacked);

                assert.equal(unpacked.typeIIIhead[0], 0);
                assert.equal(unpacked.filterPatterns[1], 'Passed filters 3, 10, 12, 13.');
                assert.equal(unpacked.waveformIndicator[0], 1);
                assert.equal(unpacked.reserved[0], 996);
                assert.equal(unpacked.pileupType, 4);

            }); 

            QUnit.test("typeIV", function( assert ){
                unpacked = {};
                parser.parsers['IV'](data[3], unpacked);

                assert.equal(unpacked.typeIVhead[0][0], 0);
                assert.equal(unpacked.filterConditionCounterValue[0][0], 0x73F461FF);

            }); 

            QUnit.test("typeV", function( assert ){
                unpacked = {};
                parser.parsers['V'](data[4], unpacked);

                assert.equal(unpacked.typeVPacketType, 0x9);
                assert.equal(unpacked.channelTriggerCounterValue, 0xD74A998);

            }); 

            QUnit.test("typeVI", function( assert ){
                unpacked = {};
                parser.parsers['VI'](data[5], unpacked);

                assert.equal(unpacked.typeVIPacketType, 0xA);
                assert.equal(unpacked.timestampLowBits[0], 0x574A998);
              
            }); 

            QUnit.test("typeVII", function( assert ){
                unpacked = {};
                parser.parsers['VII'](data[6], unpacked);

                assert.equal(unpacked.typeVIIPacketType, 0xB);
                assert.equal(unpacked.deadtime[1], 124330+' ns');
                assert.equal(unpacked.timestampHighBits[0], 0x21FF)
              
            }); 

            QUnit.test("typeVIIa", function( assert ){
                unpacked = {};
                parser.parsers['VIIa'](data[7], unpacked);

                assert.equal(unpacked.typeVIIaPacketType, 0xC);
                assert.equal(unpacked.waveformSample, 0xDE);

            }); 

            QUnit.test("typeVIII", function( assert ){
                unpacked = {};
                parser.parsers['VIII'](data[11], unpacked);

                assert.equal(unpacked.typeVIIIhead[0], 0);
                assert.equal(unpacked.upperIntLength[0], 1);
                assert.equal(unpacked.pulseHeight[1], 0x17715CC + ' ADC chan');
              
            }); 

            QUnit.test("typeIX", function( assert ){
                unpacked = {};
                parser.parsers['IX'](data[12], unpacked);

                assert.equal(unpacked.typeIXhead[0], 0);
                assert.equal(unpacked.lowerIntLength[0], 1);
                assert.equal(unpacked.CFD[1], 0x34A998*10 + ' ns');
              
            }); 

            QUnit.test("typeX", function( assert ){
                unpacked = {};
                parser.parsers['X'](data[13], unpacked);

                assert.equal(unpacked.typeXpacketType[0], 0xE);
                assert.equal(unpacked.channelAcceptedCounterValue[0], 8658);
                assert.equal(unpacked.eventTrailerChannelTriggerCounterValue[0], 10648);
              
            }); 



            QUnit.module('GRIF-16 fragment post-processing', {
                "setup": function(){
                    parser = new GRIF16fragmentParser;

                    unpacked = {};
                    parser.parsers['I'](data[0], unpacked);
                    parser.parsers['II'](data[1], unpacked);
                    parser.parsers['III'](data[2], unpacked);
                    parser.parsers['IV'](data[3], unpacked);
                    parser.parsers['V'](data[4], unpacked);
                    parser.parsers['VI'](data[5], unpacked);
                    parser.parsers['VII'](data[6], unpacked);
                    parser.parsers['VIIa'](data[7], unpacked);
                    parser.parsers['VIII'](data[11], unpacked);
                    parser.parsers['IX'](data[12], unpacked);
                    parser.parsers['X'](data[13], unpacked);
                },

                "teardown": function(){
                    return 0;
                }
            });

            QUnit.test("timestamp", function ( assert ){

                parser.reconstructTimestamp(unpacked);
                assert.equal(unpacked.timestamp[1], 2.33628530524E+13+' ns');
            });

            QUnit.test("integrationLength", function ( assert ){

                parser.reconstructIntegrationLength(unpacked);
                assert.equal(unpacked.integrationLength[0], 513);
            });

            QUnit.module('GRIF-16 fragment full chain processing', {
                "setup": function(){
                    parser = new GRIF16fragmentParser;

                    dataStore = {};
                    unpacked = {};
                    parser.parsers['I'](data[0], unpacked);
                    parser.parsers['II'](data[1], unpacked);
                    parser.parsers['III'](data[2], unpacked);
                    parser.parsers['IV'](data[3], unpacked);
                    parser.parsers['V'](data[4], unpacked);
                    parser.parsers['VI'](data[5], unpacked);
                    parser.parsers['VII'](data[6], unpacked);
                    parser.parsers['VIIa'](data[7], unpacked);
                    parser.parsers['VIII'](data[11], unpacked);
                    parser.parsers['IX'](data[12], unpacked);
                    parser.parsers['X'](data[13], unpacked);
                },

                "teardown": function(){
                    return 0;
                }
            });

            QUnit.test("assessComposition", function ( assert ){

                var flags = parser.assessComposition(data),
                    buffer;

                //nominally correct
                assert.deepEqual(flags, []);

                //not enough words
                buffer = data.slice(1,2)
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Not enough words to make an event.'])

                //wrong first word
                buffer = data.slice()
                buffer[0] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['First word does not start with 0x8'])

                //wrong second word
                buffer = data.slice()
                buffer[1] = 0xBEEFBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Second word does not start with 0xD'])

                //wrong third word
                buffer = data.slice()
                buffer[2] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Third word does not start with 00'])

                //wrong fourth word
                buffer = data.slice()
                buffer[3] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.equal(flags[0], 'Fourth word does not start with 0')

                //make sure the right number of type IV words is detected
                flags = parser.assessComposition(data)
                assert.equal(dataStore.GRIF16fragmentDetails.nTypeIV, 1)

                //wrong type V identifier
                buffer = data.slice()
                buffer[4] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Missing type V word or type V word out of sequence'])

                //wrong type VI identifier
                buffer = data.slice()
                buffer[5] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Missing type VI word or type VI word out of sequence'])

                //wrong type VII identifier
                buffer = data.slice()
                buffer[6] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Missing type VII word or type VII word out of sequence'])

                //make sure the right number of type IV words is detected
                flags = parser.assessComposition(data)
                assert.equal(dataStore.GRIF16fragmentDetails.nTypeVIIa, 4)

                //wrong type VIII identifier
                buffer = data.slice()
                buffer[11] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Missing type VIII word or type VIII word out of sequence'])

                //wrong type IX identifier
                buffer = data.slice()
                buffer[12] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Missing type IX word or type IX word out of sequence'])

                //wrong type X identifier
                buffer = data.slice()
                buffer[13] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Missing type X word or type X word out of sequence'])

                //junk at the end
                buffer = data.slice()
                buffer[14] = 0xDEADBEEF
                flags = parser.assessComposition(buffer)
                assert.deepEqual(flags, ['Type X word not the final word in the event'])

            });

        </script>
      </body>
</html>